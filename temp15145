diff --git a/app/controllers/taxa_controller.rb b/app/controllers/taxa_controller.rb
index 6788476..26564a3 100644
--- a/app/controllers/taxa_controller.rb
+++ b/app/controllers/taxa_controller.rb
@@ -43,7 +43,6 @@ class TaxaController < ApplicationController
     raise "boom" 
   end
 
-  # TODO - log that a search was performed
   def search
     # remove colon from query, because it reserved for fields separation
     @colon_warning_flag = 0
@@ -53,14 +52,16 @@ class TaxaController < ApplicationController
     else 
       @querystring   = params[:q] || params[:id]
     end
-    @search_type     = params[:search_type] || 'text'
-    @page_title      = "EOL Search: #{@querystring}"
-    if @search_type    == 'google'
-      render :html => 'google_search'
+    @search_type = params[:search_type] || 'text'
+    @page_title  = "EOL Search: #{@querystring}"
+    @parent_search_log_id = params[:search_log_id] || 0 # Keeps track of searches done immediately after other searches
+    log_search(request)
+    if @search_type == 'google'
+      render :action => 'google_search'
     elsif @search_type == 'tag'
       search_tag
     else
-      search_text      
+      search_text
     end
   end
 
@@ -116,7 +117,7 @@ class TaxaController < ApplicationController
   def search_tag
     @search = Search.new(params, request, current_user, current_agent)
     # The Search class (above) is using 'old' result sets, which we need to adapt to the Solr-style:
-    results = adapt_old_tag_search_results_to_solr_style_results(@search.search_results[:tags])
+    results = EOL::SearchResultsCollection.adapt_old_tag_search_results_to_solr_style_results(@search.search_results[:tags])
     if current_user.expertise.to_s == 'expert'
       @scientific_results = results.paginate(:page => 1, :per_page => results.length + 1, :total_entries => results.length)
       @common_results = empty_paginated_set
@@ -134,7 +135,7 @@ class TaxaController < ApplicationController
     else
       @suggested_results  = get_suggested_search_results(@querystring)
       # Are we passing params here for pagination?
-      @scientific_results = TaxonConcept.search_with_pagination(@querystring, params)
+      @scientific_results = TaxonConcept.search_with_pagination(@querystring, params.merge(:type => :scientific))
       @common_results     = TaxonConcept.search_with_pagination(@querystring, params.merge(:type => :common))
       
       @all_results = (@suggested_results + @scientific_results + @common_results)
@@ -218,7 +219,7 @@ class TaxaController < ApplicationController
     else
       @new_text_tocitem_id = get_new_text_tocitem_id(@category_id)
       render :update do |page|
-        page.replace_html 'center-page-content', :partial => 'content.html.erb'
+        page.replace_html 'center-page-content', :partial => 'content'
         page << "$('current_content').value = '#{@category_id}';"
         page << "Event.addBehavior.reload();"
         page << "EOL.TextObjects.update_add_links('#{url_for({:controller => :data_objects, :action => :new, :type => :text, :taxon_concept_id => @taxon_concept.id, :toc_id => @new_text_tocitem_id})}');"
@@ -332,15 +333,12 @@ class TaxaController < ApplicationController
       name, synonym, taxon_concept_name = tc.add_common_name params[:name][:name_string]
       agent_role = AgentRole.find_by_label("Contributor")
       agent = Agent.find(current_user.agent_id)
-    if tc.is_curatable_by?(current_user)
-      as = AgentsSynonym.create!(:synonym    => synonym, 
-                                 :agent      => agent, 
-                                 :agent_role => agent_role, 
-                                 :view_order => 0)
-    else
-      flash[:error] = "User #{current_user.full_name} does not have enough privileges to add a common name to the taxon"
-    end
-    expire_taxa(tc.id)
+      if tc.is_curatable_by?(current_user)
+        as = AgentsSynonym.create!(:synonym => synonym, :agent => agent, :agent_role => agent_role, :view_order => 0)
+      else
+        flash[:error] = "User #{current_user.full_name} does not have enough privileges to add a common name to the taxon"
+      end
+      expire_taxa(tc.id)
     end
     redirect_to "/pages/#{tc.id}?category_id=#{params[:name][:category_id]}"
   end
@@ -665,7 +663,7 @@ private
   helper_method(:search_fragment_name)
 
   def redirect_to_taxa_page(result_set)
-    redirect_to :controller => 'taxa', :action => 'show', :id => result_set.first['taxon_concept_id']
+    redirect_to :controller => 'taxa', :action => 'show', :id => result_set.first['id']
   end
 
   def get_suggested_search_results(querystring)
@@ -705,20 +703,26 @@ private
     [].paginate(:page => 1, :per_page => 10, :total_entries => 0)
   end
 
-  def adapt_old_tag_search_results_to_solr_style_results(results)
-    results.map do |tag_result|
-      tc = tag_result[0]
-      dato = tag_result[1]
-      common_name = tc.common_name(@session_hierarchy)
-      {'taxon_concept_id'          => [tc.id],
-       'vetted_id'                 => [tc.vetted_id],
-       'preferred_scientific_name' => [tc.scientific_name(@session_hierarchy)],
-       'common_name'               => [common_name],
-       'preferred_common_name'     => [common_name],
-       'best_matched_common_name'  => common_name,
-       'title'                     => tc.title(@session_hierarchy),
-       'top_image_id'              => dato.id }
-    end
+  # Add an entry to the database desrcibing the fruitfullness of this search.
+  def log_search(req)
+    logged_search = SearchLog.log(
+      {:search_term                       => @querystring,
+       :search_type                       => @search_type,
+       :parent_search_log_id              => @parent_search_log_id,
+       :total_number_of_results           => get_num_results(@all_results),
+       :number_of_common_name_results     => get_num_results(@common_results),
+       :number_of_scientific_name_results => get_num_results(@scientific_results),
+       :number_of_suggested_results       => get_num_results(@suggested_results) },
+      req,
+      current_user)
+    @logged_search_id = logged_search.nil? ? '' : logged_search.id
+  end
+
+  def get_num_results(set)
+    return 0 if set.nil?
+    set.respond_to?(:total_entries) ?
+      set.total_entries :
+      set.length
   end
 
 end
diff --git a/app/views/taxa/_search_results_table.html.haml b/app/views/taxa/_search_results_table.html.haml
index e7de33c..d33df8f 100644
--- a/app/views/taxa/_search_results_table.html.haml
+++ b/app/views/taxa/_search_results_table.html.haml
@@ -1,7 +1,4 @@
 - unless results.blank?
-  - if @colon_warning_flag == 1
-    %h2== Sorry, there is no result with a colon "#{params[:q]}". See result for "#{@querystring}".
-    %br
   .search_results{ :id => title.downcase.gsub(" ", "_")}
     %h3.search_result_subtitle= "#{title}"[]
     %p
diff --git a/app/views/taxa/search.html.haml b/app/views/taxa/search.html.haml
index 62bd660..512a378 100644
--- a/app/views/taxa/search.html.haml
+++ b/app/views/taxa/search.html.haml
@@ -6,6 +6,9 @@
     - if @all_results.blank?
       %h3 No search results were found
     - else
+      - if @colon_warning_flag == 1
+        %h2== Sorry, there is no result for "#{params[:q]}" with a colon. See result for "#{@querystring}".
+        %br
       = render :partial => 'search_results_table', :locals => {:title => 'Suggested Search Results', :results => @suggested_results }
       = render :partial => 'search_results_table', :locals => {:title => 'Common Names Search Results', :results => @common_results }
       = render :partial => 'search_results_table', :locals => {:title => 'Scientific Names Search Results', :results => @scientific_results }
diff --git a/lib/eol/solr_search.rb b/lib/eol/solr_search.rb
index cfd4979..2c6fb76 100644
--- a/lib/eol/solr_search.rb
+++ b/lib/eol/solr_search.rb
@@ -11,8 +11,13 @@ module EOL
         options[:search_type] ||= :common_name
         clean_query = options[:escape_query_underscore] ? query.gsub('_', ' ') : query # Handles some of the "clean" URL "ids" that may get passed in.
         querystring = ''
-        # This was just a raw string, we need to make a query out of it:
-        querystring = prepare_querystring(clean_query, options)
+        if clean_query =~ /:/ # This was passed in as a prepared querystring TODO - this s/b a separate method
+          querystring  = clean_query
+          @@field_spec = /\w+:/
+          query        = clean_query.gsub(@@field_spec, '') # TODO - this may not handle complex querystrings well.
+        else # This was just a raw string, we need to make a query out of it:
+          querystring = prepare_querystring(clean_query, options)
+        end
         res  = solr_search(querystring, options)
         data = EOL::SearchResultsCollection.new(res['response']['docs'],
                                                 options.merge(
