- glossary = []
- content_for :social_sharing do
  = render :partial => 'shared/social_sharing'
-# TODO - These should actually be links to filtered versions of this page, for accessibility.
- include_other_category = !@data_point_uris.empty? && (@data_point_uris.detect{ |d| d.predicate_known_uri.nil? || d.predicate_known_uri.toc_items.blank? })
#tabs_sidebar.data
  -# NOTE - subtabs class adds behavior, tabs subclass adds style. We need both (q.v. about.html.haml)
  %ul.subtabs.tabs.with_icons
    - @categories.each do |cat|
      %li{ class: (@toc_id == cat.id.to_s) ? 'active' : nil }= link_to cat.label, url_for(params.merge(:toc_id => cat.id)), 'data-toc-id' => cat.id
    - if include_other_category
      %li{ class: (@toc_id == 'other') ? 'active' : nil }= link_to I18n.t(:other_category), url_for(params.merge(:toc_id => 'other')), 'data-toc-id' => 'other'
    %li{ class: @toc_id ? nil : 'active' }= link_to I18n.t(:all_categories), url_for(params.merge(:toc_id => nil)), class: 'all'
    %li.about= link_to I18n.t(:data_subtab_about), about_taxon_data_path(@taxon_page), remote: true
.main_container#taxon_data
  %h3.assistive= I18n.t(:taxon_data_header, taxon: @taxon_page.scientific_name)
  = render :partial => 'about', :locals => { hidden: true }
  - if @data_point_uris.empty?
    .empty
      %p= I18n.t(:taxon_data_empty)
  - else
    - category_toc_items = @data_point_uris.collect{ |d| d.predicate_known_uri ? d.predicate_known_uri.toc_items : nil }.flatten.compact.uniq.sort_by(&:view_order)
    - if include_other_category
      -# adding nil here to represent no TOC, i.e. the 'other' cagtegory
      - category_toc_items << nil
    - category_toc_items.each do |category_toc_item|
      -# TODO - move this to the "model" (except the class-setting logic)
      - show_table = true
      - if @toc_id
        - show_table = category_toc_item.nil? ? (@toc_id == 'other') : (@toc_id == category_toc_item.id.to_s)
      .header_underlined{ style: show_table ? nil : 'display: none;' }
        %h3= category_toc_item.nil? ? I18n.t(:other_category) : category_toc_item.label
      %table.standard.data{:summary => I18n.t(:data_table_summary, taxon: @taxon_page.scientific_name), style: show_table ? nil : 'display:none;',
        data: { more: I18n.t(:data_show_n_more_rows), 'toc_id' => category_toc_item.nil? ? 'other' : category_toc_item.id} }
        %caption.assistive= I18n.t(:taxon_data_header, taxon: @taxon_page.scientific_name)
        - type_index = 0
        - last_attribute = nil
        - data_for_this_category = category_toc_item.nil? ?
        -   @data_point_uris.select{ |d| d.predicate_known_uri.nil? || d.predicate_known_uri.toc_items.blank? } :
        -   @data_point_uris.select{ |d| d.predicate_known_uri && d.predicate_known_uri.toc_items.include?(category_toc_item) }
        - data_for_this_category.each do |data_point_uri|
          - classes = []
          - first_of_type = data_point_uri.predicate != last_attribute
          - if first_of_type
            - type_index += 1
            - header_id = data_point_uri.predicate
            - last_attribute = data_point_uri.predicate
            - unless data_point_uri.predicate_known_uri.blank? || data_point_uri.predicate_known_uri.definition.blank?
              - pp data_point_uri
              - glossary << data_point_uri
          - else
            - header_id = nil
          - classes << ['first_of_type'] if first_of_type
          - comments = []
          - comments = data_point_uri.comments # Need to use #all_comments because it might involve multiple instances.
          - unless data_point_uri.visible?
            - if current_user.is_curator?
              - classes << 'hidden'
            - else
              - next
          - row_is_selected = (@selected_data_point_uri_id && @selected_data_point_uri_id.to_i == data_point_uri.id)
          -# using the instance methods as opposed to scopes allows us to use preloaded taxon_data_exemplars
          - exemplar = data_point_uri.taxon_data_exemplars.select{ |ex| ex.included }.any?
          - excluded = data_point_uri.taxon_data_exemplars.select{ |ex| ex.excluded }.any?
          = render :partial => 'data_point_uris/display_rows', :locals => {    |
            :data_point_uri => data_point_uri, :type_index => type_index,      |
            :classes => classes, :exemplar => exemplar, :excluded => excluded, |
            :row_is_selected => row_is_selected, :header_id => header_id }     |
    .header_underlined
      %h3= I18n.t(:glossary_subhead)
    %ul.glossary
      - glossary.sort_by { |t| t.predicate_known_uri.name }.each do |dpuri|
        %li
          %dt{id: dpuri.predicate_known_uri.anchor}
            = dpuri.predicate_known_uri.name
            = link_to I18n.t(:more_taxa_with_attribute), data_search_path(attribute: dpuri.predicate, sort: 'desc')
            %small= dpuri.predicate
          %dd
            = raw dpuri.predicate_known_uri.definition.add_missing_hyperlinks
- if current_user.min_curator_level?(:master)
  .add_content
    %p.add_data= link_to I18n.t(:master_curators_may_add_data), '#' # Ideally, that would be a link to the user_added_data/new path...
    .article
      .header
        %h3= I18n.t('user_added_data.add_data_header')
      = render :partial => 'user_added_data/form'
      -# You can't have nested forms, so this is external. ...It will be handled by Ajax (only), anyway.
      #suggestions{ style: 'display:none;' }
        = render :partial => 'known_uris/categories'
