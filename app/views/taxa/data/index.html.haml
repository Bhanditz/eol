- content_for :social_sharing do
  = render :partial => 'shared/social_sharing'
-# TODO - These should actually be links to filtered versions of this page, for accessibility.
#tabs_sidebar.data
  -# NOTE - subtabs class adds behavior, tabs subclass adds style. We need both (q.v. about.html.haml)
  %ul.subtabs.tabs.with_icons
    - @categories.each do |cat|
      %li{ class: (@toc_id == cat.id.to_s) ? 'active' : nil }= link_to cat.label, url_for(params.merge(:toc_id => cat.id)), 'data-toc-id' => cat.id
    %li{ class: (@toc_id == 'other') ? 'active' : nil }= link_to I18n.t(:other_category), url_for(params.merge(:toc_id => 'other')), class: 'other'
    %li{ class: @toc_id ? nil : 'active' }= link_to I18n.t(:all_categories), url_for(params.merge(:toc_id => nil)), class: 'all'
    %li{ class: 'about' }= link_to I18n.t(:data_about_subtab), about_taxon_data_path(@taxon_page), remote: true
.main_container#taxon_data
  - if @data.blank?
    .empty
      %p= I18n.t(:taxon_data_empty)
  - else
    = render(partial: 'about')
    %table.standard.data{'data-more' => I18n.t(:data_show_n_more_rows)}
      - type_index = 0
      - last_attribute = nil
      - @data.each do |row|
        - next if row[:attribute].blank?
        - classes = []
        - classes = row[:attribute].toc_items.map { |ti| "toc_#{ti.id}" } if row[:attribute].is_a?(KnownUri)
        - first_of_type = row[:attribute] != last_attribute
        - if first_of_type
          - type_index += 1
        - classes = ['toc_other'] if classes.blank?
        - classes << "type_#{type_index}"
        - classes << ['first_of_type'] if first_of_type
        - classes << 'nested' if row[:attribute] == last_attribute
        - comments = []
        - data_point_uri = nil
        - comments = row[:parent].all_comments # Need to use #all_comments because it might involve multiple instances.
        -# TODO - move this to the "model" (except the class-setting logic)
        - show_row = true
        - if @toc_id == 'other'
          - show_row = false if row[:attribute].is_a?(KnownUri) && !row[:attribute].toc_items.empty?
        - elsif row[:attribute].is_a?(KnownUri)
          - show_row = false if @toc_id && row[:attribute].toc_items.detect{ |toc| toc.id.to_s == @toc_id }.nil?
        - else
          - show_row = false if @toc_id
        - unless row[:parent].visible?
          - if current_user.is_curator?
            - classes << 'hidden'
          - else
            - show_row = false
        %tr{ id: row[:parent].anchor, class: (classes + ['data']).join(' '), 'data-type' => "type_#{type_index}", style: show_row ? '' : 'display: none;' }
          - th_id = nil
          - if row[:attribute] != last_attribute
            - th_id = row[:attribute].respond_to?(:uri) ? row[:attribute].uri : row[:attribute]
          - exemplar = row[:parent].taxon_data_exemplars.any?
          %th{ id: th_id, class: exemplar ? 'exemplar' : nil }
            - if first_of_type
              - last_attribute = row[:attribute]
              = display_uri(row[:attribute])
          %td.val
            %span.fold &nbsp;
            = raw display_text_for_structured_data_row(row)

            %span.source
              = truncate(row[:source].name, length: 12)

            - unless comments.empty?
              %span.comments= image_tag('comment_indicator.png')

            -# displaying metadata
            - if row[:metadata]
              %table.meta
                - row[:metadata].each do |key, value|
                  - value = [ value ] unless value.class == Array
                  - value.each do |v|
                    %tr
                      = display_uri(key, :th)
                      - if EOL::Sparql.uri_in_eol_triplestore(v)
                        %td= link_to v, ($VIRTUOSO_FACET_BROWSER_URI_PREFIX + CGI.escape(v.to_s)), :target => 'data'
                      - else
                        = display_uri(v, :td)
        %tr{ class: (classes + ['actions']).join(' '), style: show_row ? '' : 'display: none;' }
          %td{ colspan: 2 }
            %ul
              - if row[:source]
                %li= raw I18n.t("data_provided_by_#{row[:source].class.name.underscore.downcase}", whom: link_to(row[:source].name, row[:source]))
              - if row.has_key?(:data_point_uri)
                %li= raw "&bull;"
                %li= link_to row[:data_point_uri], ($VIRTUOSO_FACET_BROWSER_URI_PREFIX + CGI.escape(row[:data_point_uri].to_s)), :target => 'data'
              - if row.has_key?(:user_added_data)
                - if current_user.can_update?(row[:user_added_data])
                  %li= raw "&bull;"
                  -# TODO: i18n
                  %li= link_to "edit", edit_user_added_datum_path(row[:user_added_data]), :method => :get
                  %li= raw "&bull;"
                  -# TODO: i18n
                  %li= link_to "delete", user_added_datum_path(row[:user_added_data]), :method => :delete, :confirm => I18n.t('this_cannot_be_undone_are_you_sure')
              - unless comments.empty?
                %li= raw "&bull;"
                - annotations_link = nil
                - if row.has_key?(:user_added_data)
                  - annotations_link = user_added_datum_comments_path(row[:user_added_data])
                - elsif data_point_uri
                  - annotations_link = data_point_uri_comments_path(data_point_uri)
                - if annotations_link
                  %li.annotations= link_to I18n.t(:annotations_with_count, count: comments.count), annotations_link
            = render partial: 'comments/for_data', locals: { comments: comments, parent: row[:parent] }
            -# TODO - this clearly needs duck-typing, as it is ridiculous to repeat onesself so much.
            - if current_user.min_curator_level?(:full)
              .additional_commands
                - if row[:parent].visible?
                  - if row[:parent].is_a? DataPointUri
                    = link_to I18n.t(:data_row_hide_button), data_point_uri_hide_path(row[:parent]), method: :put, class: :button
                  - else
                    = link_to I18n.t(:data_row_hide_button), user_added_datum_hide_path(row[:parent]), method: :put, class: :button
                - elsif row[:parent].invisible?
                  - if row[:parent].is_a? DataPointUri
                    = link_to I18n.t(:data_row_unhide_button), data_point_uri_unhide_path(row[:parent]), method: :put, class: :button
                  - else
                    = link_to I18n.t(:data_row_unhide_button), user_added_datum_unhide_path(row[:parent]), method: :put, class: :button
                - if exemplar
                  = link_to I18n.t(:data_row_remove_exemplar_button), taxon_data_exemplar_path(id: row[:parent].id, type: row[:parent].class.name, taxon_concept_id: @taxon_data.taxon_concept.id), method: :delete, class: :button
                - elsif row[:parent].visible?
                  = link_to I18n.t(:data_row_add_exemplar_button), taxon_data_exemplars_path(id: row[:parent].id, type: row[:parent].class.name, taxon_concept_id: @taxon_data.taxon_concept.id), method: :post, class: :button
- if logged_in?
  .add_content
    .article
      .header
        %h3= I18n.t('user_added_data.add_data_header')
      = render :partial => 'user_added_data/form'
      -# You can't have nested forms, so this is external. ...It will be handled by Ajax (only), anyway.
      #suggestions{ style: 'display:none;' }
        = render :partial => 'known_uris/categories'
