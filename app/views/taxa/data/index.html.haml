- content_for :social_sharing do
  = render :partial => 'shared/social_sharing'
-# TODO - These should actually be links to filtered versions of this page, for accessibility.
#tabs_sidebar.data
  %ul.tabs.with_icons
    %li{ class: @toc_id ? nil : 'active' }= link_to I18n.t(:all_categories), url_for(params.merge(:toc_id => nil)), class: 'all'
    - @categories.each do |cat|
      %li{ class: (@toc_id == cat.id.to_s) ? 'active' : nil }= link_to cat.label, url_for(params.merge(:toc_id => cat.id)), 'data-toc-id' => cat.id
    %li{ class: (@toc_id == 'other') ? 'active' : nil }= link_to I18n.t(:other_category), url_for(params.merge(:toc_id => 'other')), class: 'other'
.main_container#taxon_data
  - if @data.blank?
    .empty
      %p= I18n.t(:taxon_data_empty)
  - else
    %table.standard.data{'data-more' => I18n.t(:data_show_n_more_rows)}
      - type_index = 0
      - last_attribute = nil
      - @data.each do |row|
        - next if row[:attribute].blank?
        - classes = []
        - classes = row[:attribute].toc_items.map { |ti| "toc_#{ti.id}" } if row[:attribute].is_a?(KnownUri)
        - first_of_type = row[:attribute] != last_attribute
        - if first_of_type
          - type_index += 1
        - classes = ['toc_other'] if classes.blank?
        - classes << "type_#{type_index}"
        - classes << ['first_of_type'] if first_of_type
        - classes << 'nested' if row[:attribute] == last_attribute
        - comments = []
        - data_point_uri = nil
        - row_id = nil
        - if row.has_key?(:user_added_data)
          - row_id =  row[:user_added_data].anchor
          - comments = row[:user_added_data].comments
        - elsif row.has_key?(:data_point_uri)
          - data_point_uri = row[:data_point_instance]
          - row_id = data_point_uri.anchor
          - comments = data_point_uri.all_comments

        - show_row = true
        - if @toc_id == 'other'
          - show_row = false if row[:attribute].is_a?(KnownUri) && !row[:attribute].toc_items.empty?
        - elsif row[:attribute].is_a?(KnownUri)
          - show_row = false if @toc_id && row[:attribute].toc_items.detect{ |toc| toc.id.to_s == @toc_id }.nil?
        - else
          - show_row = false if @toc_id
        %tr{ id: row_id, class: (classes + ['data']).join(' '), 'data-type' => "type_#{type_index}", style: show_row ? '' : 'display: none;' }
          - th_id = nil
          - if row[:attribute] != last_attribute
            - th_id = row[:attribute].respond_to?(:uri) ? row[:attribute].uri : row[:attribute]
          %th{ id: th_id }
            - if first_of_type
              - last_attribute = row[:attribute]
              = display_uri(row[:attribute])
          %td.val
            %span.fold &nbsp;
            = raw display_text_for_structured_data_row(row)

            %span.source
              = truncate(row[:source].name, length: 12)

            - unless comments.empty?
              %span.comments= image_tag('comment_indicator.png')

            -# displaying metadata
            - if row[:metadata]
              %table.meta
                - row[:metadata].each do |key, value|
                  - value = [ value ] unless value.class == Array
                  - value.each do |v|
                    %tr
                      = display_uri(key, :th)
                      - if EOL::Sparql.uri_in_eol_triplestore(v)
                        %td= link_to v, ($VIRTUOSO_FACET_BROWSER_URI_PREFIX + CGI.escape(v.to_s)), :target => 'data'
                      - else
                        = display_uri(v, :td)
        %tr{ class: (classes + ['actions']).join(' '), style: show_row ? '' : 'display: none;' }
          %td{ colspan: 2 }
            %ul
              - if row[:source]
                %li= raw I18n.t("data_provided_by_#{row[:source].class.name.underscore.downcase}", whom: link_to(row[:source].name, row[:source]))
              - if row.has_key?(:data_point_uri)
                %li= raw "&bull;"
                %li= link_to row[:data_point_uri], ($VIRTUOSO_FACET_BROWSER_URI_PREFIX + CGI.escape(row[:data_point_uri].to_s)), :target => 'data'
              - if row.has_key?(:user_added_data)
                - if current_user.can_update?(row[:user_added_data])
                  %li= raw "&bull;"
                  -# TODO: i18n
                  %li= link_to "edit", edit_user_added_datum_path(row[:user_added_data]), :method => :get
                  %li= raw "&bull;"
                  -# TODO: i18n
                  %li= link_to "delete", user_added_datum_path(row[:user_added_data]), :method => :delete, :confirm => I18n.t('this_cannot_be_undone_are_you_sure')
              - unless comments.empty?
                %li= raw "&bull;"
                - annotations_link = nil
                - if row.has_key?(:user_added_data)
                  - annotations_link = user_added_datum_comments_path(row[:user_added_data])
                - elsif data_point_uri
                  - annotations_link = data_point_uri_comments_path(data_point_uri)
                - if annotations_link
                  %li.annotations= link_to I18n.t(:annotations_with_count, count: comments.count), annotations_link
            - if logged_in?
              = render partial: 'comments/for_data', locals: { comments: comments,
                parent: data_point_uri || row[:user_added_data] }
- if logged_in?
  .add_content
    .article
      .header
        %h3= I18n.t('user_added_data.add_data_header')
      = render :partial => 'user_added_data/form'
      -# You can't have nested forms, so this is external. ...It will be handled by Ajax (only), anyway.
      #suggestions{ style: 'display:none;' }
        = render :partial => 'known_uris/categories'
