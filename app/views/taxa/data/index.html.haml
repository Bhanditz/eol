- content_for :social_sharing do
  = render :partial => 'shared/social_sharing'
-# TODO - These should actually be links to filtered versions of this page, for accessibility.
#tabs_sidebar.data
  %ul.tabs.with_icons
    %li.active= link_to I18n.t(:all_categories), '#', class: 'all'
    - @categories.each do |cat|
      %li= link_to cat.label, '#', 'data-toc-id' => cat.id
    %li= link_to I18n.t(:other_category), '#', class: 'other'
.main_container#taxon_data
  %table.standard.data{'data-more' => I18n.t(:data_show_n_more_rows)}
    - last_attribute = nil
    - @data.each do |row|
      - next if row[:attribute].blank?
      - classes = []
      - classes = row[:attribute].toc_items.map { |ti| "toc_#{ti.id}" } if row[:attribute].is_a?(KnownUri)
      - classes = ['toc_other'] if classes.blank?
      - classes << 'nested' if row[:attribute] == last_attribute
      - comments = []
      - data_point_uri = nil
      - row_id = nil
      - if row.has_key?(:user_added_data) 
        - row_id =  row[:user_added_data].anchor
        - comments = row[:user_added_data].comments
      - elsif row.has_key?(:data_point_uri)
        -# NOTE - this is /slightly/ scary, as it generates new URIs on the fly, and (TODO) this doesn't belong in
        -# the view:
        - data_point_uri = DataPointUri.find_or_create_by_taxon_concept_id_and_uri(@taxon_page.taxon_concept_id, row[:data_point_uri])
        - row_id = data_point_uri.anchor
        - comments = data_point_uri.comments
      %tr{ id: row_id, class: (classes + ['data']).join(' ') }
        %th
          - if row[:attribute] != last_attribute
            = display_uri(row[:attribute])
        %td.val
          %span.fold &nbsp;
          - # displaying values
          - if row[:target_taxon_concept_id] && target_taxon_concept = TaxonConcept.find(row[:target_taxon_concept_id].to_s.split("/").last)
            = link_to raw(target_taxon_concept.title), taxon_data_path(target_taxon_concept)
          - else
            = display_uri(row[:value])

          - # displaying unit of measure
          - if row[:metadata] && uri_components = EOL::Sparql.get_unit_components_from_metadata(row[:metadata])
            = display_uri(uri_components)
          - elsif uri_components = EOL::Sparql.components_of_unit_of_measure_label_for_uri(row[:attribute])
            = display_uri(uri_components)

          %span.source
            = truncate(row[:source].name, length: 12)

          - unless comments.empty?
            %span.comments= image_tag('comment_indicator.png')

          -# displaying metadata
          - if row[:metadata]
            %table.meta
              - row[:metadata].each do |key, value|
                - value = [ value ] unless value.class == Array
                - value.each do |v|
                  %tr
                    = display_uri(key, :th)
                    - if EOL::Sparql.uri_in_eol_triplestore(v)
                      %td= link_to v, ($VIRTUOSO_FACET_BROWSER_URI_PREFIX + CGI.escape(v.to_s)), :target => 'data'
                    - else
                      = display_uri(v, :td)
      %tr{ class: (classes + ['actions']).join(' ') }
        %td{ colspan: 2 }
          %ul
            - if row[:source]
              %li= raw I18n.t("data_provided_by_#{row[:source].class.name.underscore.downcase}", whom: link_to(row[:source].name, row[:source]))
            - if row.has_key?(:data_point_uri)
              %li= raw "&bull;"
              %li= link_to row[:data_point_uri], ($VIRTUOSO_FACET_BROWSER_URI_PREFIX + CGI.escape(row[:data_point_uri].to_s)), :target => 'data'
            - if row.has_key?(:user_added_data) 
              - if current_user.can_update?(row[:user_added_data])
                %li= raw "&bull;"
                -# TODO: i18n
                %li= link_to "edit", edit_user_added_datum_path(row[:user_added_data]), :method => :get
                %li= raw "&bull;"
                -# TODO: i18n
                %li= link_to "delete", user_added_datum_path(row[:user_added_data]), :method => :delete, :confirm => I18n.t('this_cannot_be_undone_are_you_sure')
            - unless comments.empty?
              %li= raw "&bull;"
              - annotations_link = nil
              - if row.has_key?(:user_added_data)
                - annotations_link = user_added_datum_comments_path(row[:user_added_data])
              - elsif data_point_uri
                - annotations_link = data_point_uri_comments_path(data_point_uri)
              - if annotations_link
                %li.annotations= link_to I18n.t(:annotations_with_count, count: comments.count), annotations_link
          .comments
            - unless comments.empty?
              - comments.each do |comment|
                .comment
                  = sanitize comment.body.balance_tags.add_missing_hyperlinks
                  &ndash;
                  = link_to comment.user.full_name, comment.user
          = form_for(Comment.new(user: current_user, parent: data_point_uri || row[:user_added_data]), remote: true) do |f|
            %fieldset
              = f.hidden_field :user_id
              = f.hidden_field :parent_type
              = f.hidden_field :parent_id
            %fieldset
              = f.text_field :body, class: 'has_default', 'data-default' => I18n.t(:annotation_body_default)
            %fieldset
              = submit_tag I18n.t(:annotation_submit)
      - last_attribute = row[:attribute]
.add_content
  .article
    .header
      %h3= I18n.t('user_added_data.add_data_header')
    = render :partial => 'user_added_data/form'
    -# You can't have nested forms, so this is external. ...It will be handled by Ajax (only), anyway.
    #suggestions{ style: 'display:none;' }
      = render :partial => 'known_uris/categories'
