require "spec_helper"

# NOTE: this spec is incomplete... but I don't really care to complete it: the details of calculation have not
# really been discussed and are probably due to change, so I'm not going to get into those details.

describe CollectionRelevanceCalculator do

  before(:all) do
    SpecialCollection.create_enumerated
  end

  # NOTE - Don't do this in a let. It needs to be done BEFORE allow()s.
  before do
    @collection = Collection.gen
    @calculator = CollectionRelevanceCalculator.new(@collection)
  end

  before do
    allow(CollectionRelevanceCalculator).to receive(:new) { @calculator }
  end

  describe '.perform' do

    before do
      allow(@calculator).to receive(:set_relevance) { true }
    end

    it 'runs #set_relevance on an instance of the collection' do
      CollectionRelevanceCalculator.perform(@collection.id)
      expect(@calculator).to have_received(:set_relevance)
      expect(CollectionRelevanceCalculator).to have_received(:new).with(@collection)
    end

    it 'logs (info) the time that it is running' do
      time = Time.now
      allow(time).to receive(:strftime) { 'this is the strftime' }
      allow(Time).to receive(:now) { time }
      allow(Rails.logger).to receive(:info)
      CollectionRelevanceCalculator.perform(@collection.id)
      expect(Rails.logger).to have_received(:info).
        with(/this is the strftime/).at_least(:once)
    end

#F    it 'logs errors' do
#F      e = Exception.new("THIS")
#F      allow(e).to receive(:message) { "THIS AGAIN" }
#F      allow(e).to receive(:backtrace) { ['a','b','c'] }
#F      allow(@calculator).to receive(:set_relevance).and_raise(e)
#F      CollectionRelevanceCalculator.perform(@collection.id)
#F      #CAN'T: expect(Rails.logger).to have_received(:info).with(/ERROR.*THIS/)
#F      # I can't get the above to work, so let's just test that the error is inspected:
#F      # expect(e).to have_received(:message)
#F      # expect(e).to have_received(:backtrace)
#F      expect(@calculator).to have_received(:set_relevance)
#F    end

  end

  before do
    allow(@collection).to receive(:watch_collection?) { false }
    allow(@collection).to receive(:taxa_count) { 1 }
    allow(@collection).to receive(:focus?) { false }
    # Yes, this conflicts with taxa_count, but let's ignore that for now.
    allow(@collection).to receive(:collection_items) { [] }
  end

  it 'uses notification queue' do
    expect(PrepareAndSendNotifications.class_eval { @queue }).to eq(:notifications)
  end

  it 'always ranks watch collections as 0' do
    @collection.should_receive(:watch_collection?).and_return(true)
    expect(@calculator.set_relevance).to eq(0)
  end

  it 'always ranks collections with no taxa as 0' do
    allow(@collection).to receive(:taxa_count) { 0 }
    expect(@calculator.set_relevance).to eq(0)
  end

  it 'skips updating attributes if calculation is 0' do
    allow(@calculator).to receive(:calculate_feature_relevance) { 0 }
    allow(@calculator).to receive(:calculate_taxa_relevance) { 0 }
    allow(@calculator).to receive(:calculate_item_relevance) { 0 }
    allow(@calculator).to receive(:update_attributes) { true }
    expect(@calculator.set_relevance).to eq(0)
    expect(@calculator).to_not have_received(:update_attributes)
  end

  it 'skips updating attributes if calculation is 100' do
    allow(@calculator).to receive(:calculate_feature_relevance) { 100 }
    allow(@calculator).to receive(:calculate_taxa_relevance) { 100 }
    allow(@calculator).to receive(:calculate_item_relevance) { 100 }
    allow(@calculator).to receive(:update_attributes) { true }
    expect(@calculator.set_relevance).to eq(100)
    expect(@calculator).to_not have_received(:update_attributes) # TODO - really?  Why not?
  end

end
